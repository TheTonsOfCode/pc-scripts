#!/usr/bin/env bash

# --- Configuration ---
# Directory to store packed packages and version data
LOCALPACKS_DIR="$HOME/.localpacks"
# File storing alias and version information
DATA_FILE="$LOCALPACKS_DIR/data.json"
# Configuration filename
CONFIG_FILE=".localpack.json"

# --- Helper Functions ---
function print_usage {
  echo "Usage:"
  echo "  localpack [pack <alias> [directory]|i|install <alias>|help]"
  echo "  localpack                           - Uses localpack.json to pack or install."
  echo "  localpack pack <alias> [directory]  - Builds, packs, versions, and stores the package."
  echo "                                      If [directory] is provided, 'npm pack' runs inside it."
  echo "                                      Replaces '/' with '-' in the saved .tgz filename."
  echo "                                      Removes the previous .tgz for this alias."
  echo "  localpack i|install <alias>         - Installs the latest version of the package associated with <alias>."
  echo "  localpack help                      - Shows this help message."
}

function ensure_jq {
  # Check if jq command is available
  if ! command -v jq &> /dev/null; then
    echo "Error: 'jq' command not found. Please install jq (e.g., 'brew install jq')."
    exit 1
  fi
}

function ensure_localpacks_setup {
  # Ensure the main storage directory exists
  mkdir -p "$LOCALPACKS_DIR"
  # Initialize the data file if it doesn't exist
  if [ ! -f "$DATA_FILE" ]; then
    echo "{}" > "$DATA_FILE"
    echo "Initialized data file at $DATA_FILE"
  fi
}

function read_data {
  # Read the entire data file content
  jq '.' "$DATA_FILE"
}

function write_data {
  # Safely write JSON content to the data file using a temporary file
  local json_content="$1"
  local tmp_file
  tmp_file=$(mktemp)
  # Validate JSON before writing
  if echo "$json_content" | jq '.' > "$tmp_file"; then
    mv "$tmp_file" "$DATA_FILE"
  else
    echo "Error: Failed to write updated data to $DATA_FILE. Invalid JSON generated."
    rm "$tmp_file" # Clean up temp file
    exit 1
  fi
}

function get_alias_info {
  # Get the JSON object for a specific alias
  local alias="$1"
  jq -r --arg alias "$alias" '.[$alias]' "$DATA_FILE"
}

function update_alias_info {
  # Update or set the info (package name, version) for an alias
  # NOTE: Stores the ORIGINAL package name in the JSON
  local alias="$1"
  local original_package_name="$2" # Keep original name here
  local new_version="$3"

  local current_data
  current_data=$(read_data)

  local updated_data
  # Use jq to update the specific alias key
  updated_data=$(echo "$current_data" | jq \
    --arg alias "$alias" \
    --arg pkgName "$original_package_name" \
    --argjson version "$new_version" \
    '.[$alias] = {"packageName": $pkgName, "version": $version}')

  write_data "$updated_data"
}

function pack_package {
  local alias="$1"
  local directory="$2"

  if [ -z "$alias" ]; then
    echo "Error: Alias is required for 'pack' command."
    print_usage
    return 1
  fi

  local package_json_path="package.json"

  if [ ! -f "$package_json_path" ]; then
    echo "Error: 'package.json' not found at '$package_json_path'."
    return 1
  fi

  # Read ORIGINAL package name from package.json
  local original_package_name=$(jq -r '.name' "$package_json_path")
  if [ -z "$original_package_name" ] || [ "$original_package_name" == "null" ]; then
      echo "Error: Could not read package name from '$package_json_path'."
      return 1
  fi
  # Create a filesystem-safe version of the package name
  local safe_package_name=${alias//\//-}
  echo "--- Original package name: $original_package_name ---"
  echo "--- Filesystem-safe name: $safe_package_name ---"


  # Build the package
  echo "--- Running 'npm run build'... ---"
  if ! npm run build; then
    echo "Error: 'npm run build' failed."
    return 1
  fi
  echo "--- Build successful ---"

  local original_pwd=$(pwd)
  local pack_dir="." # Default pack location is current directory
  local pack_in_subdir=false

  # Check if a target directory for 'npm pack' was provided
  if [ -n "$directory" ]; then
    if [ -d "$directory" ]; then
      pack_dir="$directory"
      echo "--- Changing directory to '$pack_dir' for packing... ---"
      if ! cd "$pack_dir"; then
          echo "Error: Failed to change directory to '$pack_dir'."
          return 1
      fi
      pack_in_subdir=true
    else
      echo "Error: Provided directory '$directory' does not exist."
      cd "$original_pwd" || return 1 # Go back if cd failed before exiting
      return 1
    fi
  fi

  # Pack the package and capture the filename (last line of npm pack output)
  echo "--- Running 'npm pack' in '$PWD'... ---"
  # Note: npm pack might create a filename based on ORIGINAL_PACKAGE_NAME
  local packed_filename_relative=$(npm pack | tail -n 1)
  local npm_pack_exit_code=$?

  # Store the absolute path to the packed file *before* potentially changing back
  local packed_file_abs_path="$PWD/$packed_filename_relative"

  # Return to the original directory if we changed into a subdirectory
  if $pack_in_subdir; then
    echo "--- Returning to original directory '$original_pwd'... ---"
    if ! cd "$original_pwd"; then
        echo "Error: Failed to return to the original directory '$original_pwd'."
        # Try to continue anyway, as the file is already packed
    fi
  fi

  # Check the result of npm pack
  if [ $npm_pack_exit_code -ne 0 ] || [ -z "$packed_filename_relative" ] || [ ! -f "$packed_file_abs_path" ]; then
    echo "Error: 'npm pack' failed or did not produce a file."
    echo "Expected file at: $packed_file_abs_path"
    ls -la "$(dirname "$packed_file_abs_path")" # List directory contents for debugging if pack failed
    return 1
  fi
  # Check if the generated file name actually matches the expected safe name convention from npm>=7
  # Example: npm pack might generate '@org-pkg-1.0.0.tgz' or 'org-pkg-1.0.0.tgz'
  # We will rename it consistently using our SAFE_PACKAGE_NAME later.

  # Read the current version for the alias, defaulting to 0 if not found
  local current_version=$(jq -r --arg alias "$alias" '.[$alias].version // 0' "$DATA_FILE")
  local new_version=$((current_version + 1))
  echo "--- Versioning: '$alias' -> $new_version ---"

  # --- Clean up previous version ---
  if [ "$current_version" -gt 0 ]; then
      # Construct the filename of the previous version using the SAFE name
      local previous_tgz_filename="${safe_package_name}-${current_version}.tgz"
      local previous_tgz_path="$LOCALPACKS_DIR/$previous_tgz_filename"
      # Check if the previous version file exists and remove it
      if [ -f "$previous_tgz_path" ]; then
          echo "--- Removing previous version: $previous_tgz_path ---"
          if ! rm "$previous_tgz_path"; then
              # Log a warning but continue, as cleanup failure isn't critical
              echo "Warning: Failed to remove previous version at $previous_tgz_path."
          fi
      else
          # Inform user if no previous file was found
          echo "--- No previous version file found for $alias (safe name $safe_package_name) version $current_version to remove. ---"
      fi
  else
       # Inform user this is the first tracked version for the alias
      echo "--- This is the first tracked version ($new_version), no previous version to remove. ---"
  fi

  # --- Move and rename the newly packed file ---
  # Construct the NEW filename using the SAFE name
  local new_tgz_filename="${safe_package_name}-${new_version}.tgz"
  local target_tgz_path="$LOCALPACKS_DIR/$new_tgz_filename"

  echo "--- Moving '$packed_file_abs_path' to '$target_tgz_path'... ---"
  # The move command now uses the TARGET_TGZ_PATH which has the safe filename
  if ! mv "$packed_file_abs_path" "$target_tgz_path"; then
    echo "Error: Failed to move the packed file."
    # Add more debugging info if move fails
    echo "Source: $packed_file_abs_path"
    echo "Target: $target_tgz_path"
    echo "Source exists? $(ls -l "$packed_file_abs_path")"
    echo "Target directory exists? $(ls -ld "$LOCALPACKS_DIR")"
    return 1
  fi

  # --- Update the data file with the new version info ---
  # IMPORTANT: Store the ORIGINAL package name in the JSON data
  echo "--- Updating alias info in '$DATA_FILE' (using original name '$original_package_name')... ---"
  if update_alias_info "$alias" "$original_package_name" "$new_version"; then
      echo "--- Successfully packed and stored '$original_package_name' as '$alias' version $new_version ---"
      echo "--- Saved to: $target_tgz_path (using safe name $safe_package_name) ---"
      return 0
  else
      echo "Error: Failed to update $DATA_FILE."
      # Optional: Consider attempting to revert the move if the JSON update fails
      return 1
  fi
}

function install_package {
  local alias="$1"

  if [ -z "$alias" ]; then
    echo "Error: Alias is required for 'install' command."
    print_usage
    return 1
  fi

  # Detect '%' prefix to install as devDependency
  local install_flag=""
  if [[ "$alias" =~ ^% ]]; then
    install_flag="--save-dev"
    alias="${alias:1}"
    echo "--- Detected '%' prefix; installing as devDependency for alias '$alias' ---"
  fi

  # Read the alias information from the data file
  local alias_info=$(get_alias_info "$alias")

  # Check if alias exists in the data
  if [ "$alias_info" == "null" ] || [ -z "$alias_info" ]; then
    echo "Error: Alias '$alias' not found in $DATA_FILE."
    return 1
  fi

  # Extract ORIGINAL package name and latest version
  local original_package_name=$(echo "$alias_info" | jq -r '.packageName')
  local latest_version=$(echo "$alias_info" | jq -r '.version')

  # Validate the extracted data
  if [ -z "$original_package_name" ] || [ "$original_package_name" == "null" ] || [ -z "$latest_version" ] || [ "$latest_version" == "null" ]; then
     echo "Error: Incomplete data found for alias '$alias' in $DATA_FILE."
     return 1
  fi

  # Construct filesystem-safe name and packed filename
  local safe_package_name=${alias//\//-}
  local package_filename="${safe_package_name}-${latest_version}.tgz"

  # If package.json references this packed file, skip installation
  if [ -f "package.json" ]; then
    if jq -e --arg filename "$package_filename" \
         'any(.dependencies[]?; contains($filename)) or any(.devDependencies[]?; contains($filename))' \
         package.json > /dev/null; then
      echo "--- Dependency already references $filename in package.json; skipping npm install ---"
      return 0
    fi
  fi

  # Construct the full path to the package .tgz file
  local package_path="$LOCALPACKS_DIR/$package_filename"

  # Check if the .tgz file exists
  if [ ! -f "$package_path" ]; then
    echo "Error: Package file for '$alias' (version $latest_version) not found."
    echo "       Original name: $original_package_name"
    echo "       Expected filename: $package_filename"
    echo "       Expected path: $package_path"
    return 1
  fi

  # Install the package using npm
  echo "--- Installing '$original_package_name' version $latest_version from '$package_path' $install_flag... ---"
  if ! npm install $install_flag "$package_path"; then
    echo "Error: 'npm install $install_flag $package_path' failed."
    return 1
  fi
  echo "--- Successfully installed $alias (package '$original_package_name' version $latest_version) ${install_flag:+as devDependency} ---"
  return 0
}

function handle_config_pack {
  if [ -f "$CONFIG_FILE" ]; then
    echo "--- Found $CONFIG_FILE. Attempting to pack using its configuration... ---"
    local config=$(cat "$CONFIG_FILE")
    local alias=$(echo "$config" | jq -r '.alias')
    local directory=$(echo "$config" | jq -r '.directory')

    if [ -n "$alias" ] && [ "$alias" != "null" ]; then
      echo "--- Packing with alias: '$alias'"
      if [ -n "$directory" ] && [ "$directory" != "null" ]; then
        echo "--- Using directory: '$directory'"
        pack_package "$alias" "$directory"
      else
        pack_package "$alias"
      fi
    else
      echo "Warning: 'alias' not found or is null in $CONFIG_FILE. Ignoring."
      print_usage
      return 1
    fi
  else
    echo "Warning: $CONFIG_FILE not found. Please specify a command or create the configuration file."
    print_usage
    return 1
  fi
}

function handle_config_install {
  if [ -f "$CONFIG_FILE" ]; then
    echo "--- Found $CONFIG_FILE. Attempting to install using its configuration... ---"
    local config=$(cat "$CONFIG_FILE")
    local packs_json=$(echo "$config" | jq -r '.packs')

    if [ -n "$packs_json" ] && [ "$packs_json" != "null" ]; then
      # Iterate through the array of packages using jq
      while IFS= read -r alias; do
        alias=$(echo "$alias" | tr -d '" ') # Clean up quotes and spaces
        echo "--- Attempting to install: '$alias' ---"
        install_package "$alias"
      done <<< "$(echo "$config" | jq -r '.packs[]')"
      echo "--- Installation process complete. ---"
    else
      echo "Warning: 'packs' key not found or is null in $CONFIG_FILE. Ignoring."
      print_usage
      return 1
    fi
  else
    echo "Warning: $CONFIG_FILE not found. Please specify a command or create the configuration file."
    print_usage
    return 1
  fi
}

# --- Main Script Logic ---

# Check dependencies
ensure_jq
ensure_localpacks_setup

# Parse arguments
COMMAND=$1
ALIAS=$2
ARG3=$3 # Could be the directory for 'pack'

if [ -z "$COMMAND" ]; then
  # No command provided, check for localpack.json
  if [ -f "$CONFIG_FILE" ]; then
    config_type=$(jq -r 'if has("alias") then "pack" elif has("packs") then "install" else "unknown" end' "$CONFIG_FILE")
    case "$config_type" in
      "pack")
        handle_config_pack
        ;;
      "install")
        handle_config_install
        ;;
      "unknown")
        echo "Warning: $CONFIG_FILE found, but does not contain 'alias' or 'packs' configuration."
        print_usage
        exit 1
        ;;
    esac
  else
    echo "Warning: No command specified and $CONFIG_FILE not found."
    print_usage
    exit 1
  fi
else
  case "$COMMAND" in
    pack)
      pack_package "$ALIAS" "$ARG3"
      ;;

    i|install)
      install_package "$ALIAS"
      ;;

    help|--help|-h)
      # Display help message
      print_usage
      ;;

    *)
      # Handle unknown commands
      echo "Error: Unknown command '$COMMAND'."
      print_usage
      exit 1
      ;;
  esac
fi

exit 0